#!/usr/bin/env perl

use strict;
use File::Basename;
use Template;

# The destinations are all relative to `GHC`.
my %modules = (
    'Annotations' => { name => ['Types.Annotations'] },
    'ApiAnnotation' => { name => ['Parser.Annotation'] },
    'Ar' => {
	name => ['SystemTools.Archive'],
	doc => '__The need for "GHC.SystemTools.Archive"__
--
-- Building @-staticlib@ required the presence of libtool, and was a such restricted to mach-o only. As libtool on macOS and gnu libtool are very different, there was no simple portable way to support this.
--
-- libtool for static archives does essentially: concatinate the input archives, add the input objects, and create a symbol index. Using @ar@ for this task fails as even @ar@ (bsd and gnu, llvm, ...) do not provide the same features across platforms (e.g. index prefixed retrieval of objects with the same name.)
--
-- As Archives are rather simple structurally, we can just build the archives with Haskell directly and use ranlib on the final result to get the symbol index. This should allow us to work around with the differences/abailability of libtool across differet platforms.'
    },
    'AsmCodeGen' => {
	name => ['CmmToAssembler'],
	doc => 'This is the top-level module in the native code generator.'
    },
    'AsmUtils' => { name => ['Utilities.Assembler'] },
    'Avail' => { name => ['Types.Availability'] },
    'Bag' => {
	name => ['Data.Bag'],
	doc => 'An unordered collection with duplicates.'
    },
    'BasicTypes' => {
	name => ['Types.Basic'],
	doc => '__Miscellanous types__
--
-- This module defines a miscellaneously collection of very simple types that
--
-- * have no other obvious home,
-- * don\'t depend on any other complicated types, and
-- * are used in more than one "part" of the compiler.'
    },
    'BinFingerprint' => { name => ['Interface.Recompilation.Binary'] },
    'BinIface' => { name => ['Interface.Binary'] },
    'Binary' => { name => ['Utilities.Binary'] },
    'Bitmap' => { name => ['Data.Bitmap'] },
    'BkpSyn' => { name => ['Driver.Backpack.Syntax'] },
    'BlockId' => { name => ['Cmm.BlockId'] },
    # 'BlockLayout' => { name => ['CmmToAssembler.BlockLayout'] },
    'BooleanFormula' => { name => ['Data.BooleanFormula'] },
    'BufWrite' => { name => ['Utilities.BufferedHandle'] },
    'BuildTyCl' => { name => ['Typecheck.TypeClass.Build'] },
    'ByteCodeAsm' => { name => ['ByteCode.Assembler'] },
    'ByteCodeGen' => { name => ['CoreToByteCode'] },
    'ByteCodeInstr' => { name => ['ByteCode.Instructions'] },
    'ByteCodeItbls' => { name => ['ByteCode.Infotables'] },
    'ByteCodeLink' => { name => ['ByteCode.Linker'] },
    'ByteCodeTypes' => { name => ['ByteCode.Types'] },
    # 'CFG' => { name => ['CmmToAssembler.CFG'] },
    'CLabel' => { name => ['Cmm.CLabel'] },
    # 'Cpr' => { name => ['Types.CPR'] },
    'CPrim' => { name => ['CmmToAssembler.CPrimitives'] },
    'CSE' => { name => ['Core.Optimize.CommonSubexpressionElimination'] },
    'CallArity' => { name => ['Core.Optimize.CallArity'] },
    'CgUtils' => { name => ['SharedTermGraphToCmm.CodeGen.Utilities'] },
    'Check' => { name => ['HaskellToCore.PatternMatchCheck'] },
    'Class' => { name => ['Core.Class'] },
    # 'CliOption' => { name => ['Utilities.CLIOption'] },
    # 'ClsInst' => { name => ['Typecheck.Instance.Class'] },
    'CmdLineParser' => { name => ['Driver.CommandLineParser'] },
    'Cmm' => { name => ['Cmm'] },
    'CmmBuildInfoTables' => { name => ['Cmm.Info.Build'] },
    'CmmCallConv' => { name => ['Cmm.CallingConvention'] },
    'CmmCommonBlockElim' => { name => ['Cmm.CommonBlockElimination'] },
    'CmmContFlowOpt' => { name => ['Cmm.ControlFlowOptimizations'] },
    'CmmExpr' => { name => ['Cmm.Expression'] },
    'CmmImplementSwitchPlans' => { name => ['Cmm.Switch.Implement'] },
    'CmmInfo' => { name => ['Cmm.Info'] },
    'CmmLayoutStack' => { name => ['Cmm.LayoutStack'] },
    'CmmLex' => { name => ['Cmm.Lexer'] },
    'CmmLint' => { name => ['Cmm.Linter'] },
    'CmmLive' => { name => ['Cmm.Liveness'] },
    'CmmMachOp' => { name => ['Cmm.MachineOperations'] },
    'CmmMonad' => { name => ['Cmm.Monad'] },
    'CmmNode' => { name => ['Cmm.Node'] },
    'CmmOpt' => { name => ['Cmm.Optimizations'] },
    'CmmParse' => { name => ['Cmm.Parser'] },
    'CmmPipeline' => { name => ['Cmm.Pipeline'] },
    'CmmProcPoint' => { name => ['Cmm.ProcPoint'] },
    'CmmSink' => { name => ['Cmm.Sink'] },
    'CmmSwitch' => { name => ['Cmm.Switch'] },
    'CmmType' => { name => ['Cmm.Type'] },
    'CmmUtils' => { name => ['Cmm.Utilities'] },
    'CoAxiom' => { name => ['Core.Coercion.Axioms'] },
    'CodeGen.Platform' => { name => ['Platform.Registers'] },
    'CodeGen.Platform.ARM' => { name => ['Platform.ARM'] },
    'CodeGen.Platform.ARM64' => { name => ['Platform.ARM64'] },
    'CodeGen.Platform.NoRegs' => { name => ['Platform.NoRegisters'] },
    'CodeGen.Platform.PPC' => { name => ['Platform.PPC'] },
    'CodeGen.Platform.PPC_Darwin' => { name => ['Platform.PPC_Darwin'] },
    'CodeGen.Platform.SPARC' => { name => ['Platform.SPARC'] },
    'CodeGen.Platform.X86' => { name => ['Platform.X86'] },
    'CodeGen.Platform.X86_64' => { name => ['Platform.X86_64'] },
    'CodeOutput' => { name => ['Driver.CodeOutput'] },
    'Coercion' => { name => ['Core.Coercion'] },
    'ConLike' => { name => ['Core.ConstructorLike'] },
    'Config' => { name => ['Config'] },
    'Constants' => { name => ['Settings.Constants'] },
    # 'Constraint' => { name => ['Typecheck.Types.Constraint'] },
    'Convert' => { name => ['TemplateHaskellToHaskell'] },
    'CoreArity' => { name => ['Core.Arity'] },
    'CoreFVs' => { name => ['Core.FreeVariables'] },
    'CoreLint' => { name => ['Core.Linter'] },
    'CoreMap' => { name => ['Core.Map'] },
    'CoreMonad' => { name => ['Core.Optimize.Monad'] },
    'CoreOpt' => { name => ['Core.SimpleOptimizer'] },
    'CorePrep' => { name => ['CoreToSharedTermGraph.Prepare'] },
    'CoreSeq' => { name => ['Core.Seq'] },
    'CoreStats' => { name => ['Core.Statistics'] },
    'CoreSubst' => { name => ['Core.Substitutions'] },
    'CoreSyn' => {
	name => ['Core'],
	doc => 'Holds all the main data types for use by for the Glasgow Haskell Compiler midsection.',
	rename => [
	    { old => 'expandUnfolding_maybe', new => 'expandUnfolding' },
	    { old => 'exprToCoercion_maybe', new => 'exprToCoercion' },
	    ]
    },
    'CoreTidy' => { name => ['Core.Optimize.Tidy'] },
    'CoreToStg' => { name => ['CoreToSharedTermGraph'] },
    'CoreUnfold' => { name => ['Core.Unfold'] },
    'CoreUtils' => { name => ['Core.Utilities'] },
    'CostCentre' => { name => ['Types.CostCentre'] },
    'CostCentreState' => { name => ['Types.CostCentre.State'] },
    'Coverage' => { name => ['HaskellToCore.Coverage'] },
    'Ctype' => { name => ['Parser.CharacterClass'] },
    'DataCon' => { name => ['Core.DataConstructor'] },
    'Debug' => {
	name => ['Cmm.DebugBlock'],
	doc => 'Debugging data
--
-- Association of debug data on the Cmm level, with methods to encode it in event log format for later inclusion in profiling event logs.'
    },
    'Debugger' => {
	name => ['Runtime.Debugger'],
	doc => 'GHCi Interactive debugging commands'
    },
    'Demand' => { name => ['Types.Demand'] },
    'Desugar' => { name => ['HaskellToCore'] },
    'Digraph' => { name => ['Data.Graph.Directed'] },
    'DmdAnal' => { name => ['Core.Optimize.DemandAnalysis'] },
    # 'Dominators' => { name => ['CmmToAssembler.CFG.Dominators'] },
    'DriverBkp' => { name => ['Driver.Backpack'] },
    'DriverMkDepend' => { name => ['Driver.Makefile'] },
    'DriverPhases' => { name => ['Driver.Phases'] },
    'DriverPipeline' => { name => ['Driver.Pipeline'] },
    'DsArrows' => { name => ['HaskellToCore.Arrows'] },
    'DsBinds' => {
	name => ['HaskellToCore.Bindings'],
	doc => 'Pattern-matching bindings (HsBinds and MonoBinds)
--
-- Handles "GHC.Haskell.Bindings"; those at the top level require different handling, in that the `GHC.Core.Syntax.Rec`/`GHC.Core.Syntax.NonRec`/etc. structure is thrown away (whereas at lower levels it is preserved with @let@/@letrec@s).',
    },
    'DsCCall' => { name => ['HaskellToCore.Foreign.Call'] },
    'DsExpr' => { name => ['HaskellToCore.Expression'] },
    'DsForeign' => { name => ['HaskellToCore.Foreign.Declarations'] },
    'DsGRHSs' => { name => ['HaskellToCore.GuardedRightHandSides'] },
    'DsListComp' => { name => ['HaskellToCore.Comprehensions'] },
    'DsMeta' => { name => ['HaskellToCore.Quote'] },
    'DsMonad' => {
	name => ['HaskellToCore.Monad'],
	doc => 'monadery used in desugaring',
    },
    'DsUsage' => { name => ['HaskellToCore.Usage'] },
    'DsUtils' => { name => ['HaskellToCore.Utilities'] },
    'Dwarf' => { name => ['CmmToAssembler.DWARF'] },
    'Dwarf.Constants' => { name => ['CmmToAssembler.DWARF.Constants'] },
    'Dwarf.Types' => { name => ['CmmToAssembler.DWARF.Types'] },
    'DynFlags' => { name => ['Driver.Session'] },
    'DynamicLoading' => { name => ['Runtime.Loader'] },
    'Elf' => { name => ['SystemTools.ELF'] },
    'Encoding' => { name => ['Utilities.CharacterEncoding'] },
    'EnumSet' => { name => ['Data.EnumSet'] },
    'ErrUtils' => {
	name => ['Utilities.Error'],
	doc => 'Utilities for error reporting',
    },
    'Exception' => { name => ['Utilities.Exception'] },
    'Exitify' => { name => ['Core.Optimize.Exitify'] },
    'ExtractDocs' => { name => ['HaskellToCore.DocumentationString'] },
    'FV' => { name => ['Utilities.FreeVariables'] },
    'FamInst' => { name => ['Typecheck.Instance.Family'] },
    'FamInstEnv' => { name => ['Core.FamilyInstanceEnvironment'] },
    'FastFunctions' => { name => ['Utilities.IO.Unsafe'] },
    'FastMutInt' => { name => ['Data.FastMutableInt'] },
    'FastString' => { name => ['Data.FastString'] },
    'FastStringEnv' => { name => ['Data.FastString.Environment'] },
    'FieldLabel' => { name => ['Types.FieldLabel'] },
    'FileCleanup' => { name => ['SystemTools.FileCleanup'] },
    # 'FileSettings' => { name => ['Settings.File'] },
    'Finder' => { name => ['Driver.Finder'] },
    'Fingerprint' => { name => ['Utilities.Fingerprint'] },
    'FiniteMap' => { name => ['Data.Map.Finite'] },
    'FlagChecker' => { name => ['Interface.Recompilation.Flags'] },
    'FloatIn' => { name => ['Core.Optimize.FloatIn'] },
    'FloatOut' => { name => ['Core.Optimize.FloatOut'] },
    'ForeignCall' => { name => ['Types.ForeignCall'] },
    'Format' => { name => ['CmmToAssembler.Format'] },
    'FunDeps' => { name => ['Typecheck.Instance.FunctionalDependencies'] },
    'GHC' => { name => [] },
    # 'GHC.Settings' => { name => ['Settings.Plaform'] },
    'GHCi' => { name => ['Runtime.Interpreter'] },
    'GhcMake' => { name => ['Driver.Make'] },
    'GhcMonad' => { name => ['Driver.Monad'] },
    # 'GhcNameVersion' => { name => ['Settings.Version'] },
    'GhcPlugins' => {
	name => ['Plugins'],
	doc => 'This module is not used by GHC itself. Rather, it exports all of the functions and types you are likely to need when writing a plugin for GHC. So authors of plugins can probably get away simply with saying @import "GHC.GHC.Plugins"@.
--
--   Particularly interesting modules for plugin writers include "GHC.Core" and "GHC.Core.Optimize.Monad".',
	hidden => ['nameModule'],
	rename => [
	    { old => 'getTyVar_maybe', new => 'getTyVar' },
	    { old => 'nameModule_maybe', new => 'nameModule' },
	    { old => 'splitAppTy_maybe', new => 'splitAppTy'},
	    { old => 'splitForAllTy_maybe', new => 'splitForAllTy'},
	    { old => 'tyConAppTyCon_maybe', new => 'tyConAppTyCon'},
	    { old => 'tyConAppArgs_maybe', new => 'tyConAppArgs'},
	    ]
    },
    # 'GhcPrelude' => { name => ['Prelude'] },
    'GraphBase' => { name => ['Data.Graph.Base'] },
    'GraphColor' => { name => ['Data.Graph.Coloring'] },
    'GraphOps' => { name => ['Data.Graph.Operations'] },
    'GraphPpr' => { name => ['Data.Graph.PrettyPrint'] },
    'HaddockUtils' => { name => ['Parser.PostProcess.Haddock'] },
    'HeaderInfo' => { name => ['Parser.Header'] },
    # 'HieAst' => { name => ['Interface.Ext.AST'] },
    # 'HieBin' => { name => ['Interface.Ext.Binary'] },
    # 'HieDebug' => { name => ['Interface.Ext.Debug'] },
    # 'HieTypes' => { name => ['Interface.Ext.Types'] },
    # 'HieUtils' => { name => ['Interface.Ext.Utils'] },
    'Hooks' => { name => ['Driver.Hooks'] },
    'Hoopl.Block' => { name => ['Cmm.Dataflow.Block'] },
    'Hoopl.Collections' => { name => ['Cmm.Dataflow.Collections'] },
    'Hoopl.Dataflow' => { name => ['Cmm.Dataflow'] },
    'Hoopl.Graph' => { name => ['Cmm.Dataflow.Graph'] },
    'Hoopl.Label' => { name => ['Cmm.Dataflow.Label'] },
    'HsBinds' => { name => ['Haskell.Bindings'] },
    'HsDecls' => { name => ['Haskell.Declarations'] },
    'HsDoc' => { name => ['Haskell.DocumentationString'] },
    'HsDumpAst' => { name => ['Haskell.DumpAST'] },
    'HsExpr' => { name => ['Haskell.Expression'] },
    'HsExtension' => { name => ['Haskell.Extension'] },
    'HsImpExp' => { name => ['Haskell.ImportExport'] },
    'HsInstances' => { name => ['Haskell.Instances'] },
    'HsLit' => { name => ['Haskell.Literal'] },
    'HsPat' => { name => ['Haskell.Pattern'] },
    'HsSyn' => { name => ['Haskell'] },
    'HsTypes' => { name => ['Haskell.Types'] },
    'HsUtils' => { name => ['Haskell.Utilities'] },
    'HscMain' => { name => ['Driver.Main'] },
    'HscStats' => { name => ['Haskell.Statistics'] },
    'HscTypes' => { name => ['Driver.Types'] },
    'IOEnv' => { name => ['Data.IOEnvironment'] },
    'Id' => { name => ['Types.Id'] },
    'IdInfo' => { name => ['Types.Id.Info'] },
    'IfaceEnv' => { name => ['Interface.Environment'] },
    'IfaceSyn' => { name => ['Interface.Syntax'] },
    'IfaceType' => { name => ['Interface.Type'] },
    'Inst' => { name => ['Typecheck.Utilities.Instantiate'] },
    'InstEnv' => { name => ['Core.InstanceEnvironment'] },
    'Instruction' => { name => ['CmmToAssembler.Instruction'] },
    'InteractiveEval' => { name => ['Runtime.Eval'] },
    'InteractiveEvalTypes' => { name => ['Runtime.Eval.Types'] },
    'Json' => { name => ['Utilities.JSON'] },
    'Kind' => { name => ['Types.Kind'] },
    'KnownUniques' => { name => ['Builtin.Uniques'] },
    'Lexeme' => { name => ['Utilities.Lexeme'] },
    'Lexer' => { name => ['Parser.Lexer'] },
    'LiberateCase' => { name => ['Core.Optimize.LiberateCase'] },
    'Linker' => { name => ['Runtime.Linker'] },
    # 'LinkerTypes' => { name => ['Runtime.Linker.Types'] },
    'ListSetOps' => { name => ['Data.List.SetOperations'] },
    'ListT' => { name => ['Data.ListT'] },
    'Literal' => { name => ['Types.Literal'] },
    'Llvm' => { name => ['LLVM'] },
    'Llvm.AbsSyn' => { name => ['LLVM.Syntax'] },
    'Llvm.MetaData' => { name => ['LLVM.Metadata'] },
    'Llvm.PpLlvm' => { name => ['LLVM.PrettyPrint'] },
    'Llvm.Types' => { name => ['LLVM.Types'] },
    'LlvmCodeGen' => { name => ['CmmToLLVM'] },
    'LlvmCodeGen.Base' => { name => ['CmmToLLVM.Base'] },
    'LlvmCodeGen.CodeGen' => { name => ['CmmToLLVM.CodeGen'] },
    'LlvmCodeGen.Data' => { name => ['CmmToLLVM.Data'] },
    'LlvmCodeGen.Ppr' => { name => ['CmmToLLVM.PrettyPrint'] },
    'LlvmCodeGen.Regs' => { name => ['CmmToLLVM.Registers'] },
    'LlvmMangler' => { name => ['CmmToLLVM.Mangler'] },
    'LoadIface' => { name => ['Interface.Load'] },
    'Match' => { name => ['HaskellToCore.Match'] },
    'MatchCon' => { name => ['HaskellToCore.Match.Constructor'] },
    'MatchLit' => { name => ['HaskellToCore.Match.Literal'] },
    'Maybes' => { name => ['Data.Maybe'] },
    'MkCore' => { name => ['Core.Makers'] },
    'MkGraph' => { name => ['Cmm.Graph'] },
    'MkId' => { name => ['Types.Id.Makers'] },
    'MkIface' => { name => ['Interface.Utilities'] },
    'Module' => { name => ['Types.Module'] },
    'MonadUtils' => { name => ['Utilities.Monad.Utilities'] },
    'NCGMonad' => { name => ['CmmToAssembler.Monad'] },
    'Name' => { name => ['Types.Name'] },
    'NameCache' => { name => ['Types.Name.Cache'] },
    'NameEnv' => { name => ['Types.Name.Environment'] },
    'NameSet' => { name => ['Types.Name.Set'] },
    'NameShape' => { name => ['Types.Name.Shape'] },
    'OccName' => { name => ['Types.Name.Occurence'] },
    'OccurAnal' => { name => ['Core.Optimize.OccurenceAnalysis'] },
    'OptCoercion' => { name => ['Core.Coercion.Optimization'] },
    'OrdList' => {
	name => ['Data.List.Ordered'],
	doc => 'This is useful, general stuff for the Native Code Generator.
--
-- Provide trees (of instructions), so that lists of instructions can be appended in linear time.'
    },
    'Outputable' => { name => ['Utilities.Outputable'] },
    'PIC' => { name => ['CmmToAssembler.PIC'] },
    'PPC.CodeGen' => { name => ['CmmToAssembler.PPC.CodeGen'] },
    'PPC.Cond' => { name => ['CmmToAssembler.PPC.Conditional'] },
    'PPC.Instr' => { name => ['CmmToAssembler.PPC.Instructions'] },
    'PPC.Ppr' => { name => ['CmmToAssembler.PPC.PrettyPrint'] },
    'PPC.RegInfo' => { name => ['CmmToAssembler.PPC.Registers.Info'] },
    'PPC.Regs' => { name => ['CmmToAssembler.PPC.Registers'] },
    'PackageConfig' => { name => ['Driver.Packages.Config'] },
    'Packages' => { name => ['Driver.Packages'] },
    'Pair' => {
	name => ['Data.Pair'],
	doc => 'A simple homogeneous pair type with useful `Functor`, `Applicative`, and `Traversable` instances.'
    },
    'Panic' => { name => ['Utilities.Panic'] },
    'Parser' => { name => ['Parser'] },
    'PatSyn' => { name => ['Core.PatternSynonym'] },
    'PipelineMonad' => { name => ['Driver.Pipeline.Monad'] },
    'PlaceHolder' => { name => ['Haskell.Placeholder'] },
    # 'PlainPanic' => { name => ['Utilities.Panic.Plain'] },
    'Platform' => { name => ['Platform'] },
    'PlatformConstants' => { name => ['Settings.Constants.Platform'] },
    'Plugins' => { name => ['Driver.Plugins'] },
    'PmExpr' => { name => ['HaskellToCore.PatternMatchCheck.Expression'] },
    # 'PmOracle' => { name => ['HaskellToCore.PatternMatchCheck.Oracle'] },
    # 'PmPpr' => { name => ['HaskellToCore.PatternMatchCheck.PrettyPrint'] },
    # 'PmTypes' => { name => ['HaskellToCore.PatternMatchCheck.Types'] },
    'PprBase' => { name => ['CmmToAssembler.PrettyPrint'] },
    'PprC' => { name => ['CmmToC'] },
    'PprCmm' => { name => ['Cmm.PrettyPrint'] },
    'PprCmmDecl' => { name => ['Cmm.PrettyPrint.Declaration'] },
    'PprCmmExpr' => { name => ['Cmm.PrettyPrint.Expression'] },
    'PprColour' => { name => ['Utilities.PrettyPrint.Colour'] },
    'PprCore' => { name => ['Core.PrettyPrint'] },
    'PprTyThing' => { name => ['Core.PrettyPrint.TypecheckableThing'] },
    # 'Predicate' => { name => ['Core.Predicate'] },
    'PrelInfo' => { name => ['Builtin.Utilities'] },
    'PrelNames' => { name => ['Builtin.Names'] },
    'PrelRules' => { name => ['Core.Optimize.ConstantFold'] },
    'Pretty' => { name => ['Utilities.PrettyPrint'] },
    'PrimOp' => { name => ['Builtin.PrimitiveOperations'] },
    'ProfInit' => { name => ['Driver.ProfilingInit'] },
    'RdrHsSyn' => {
	name => ['Parser.PostProcess'],
	doc => 'Functions over "GHC.Haskell.Syntax" specialised to `GHC.Reader.Name.RdrName`.'
    },
    'RdrName' => { name => ['Types.Name.Reader'] },
    'Reg' => { name => ['Platform.Register'] },
    'RegAlloc.Graph.ArchBase' => { name => ['CmmToAssembler.RegisterAllocator.Graph.Base'] },
    'RegAlloc.Graph.ArchX86' => { name => ['CmmToAssembler.RegisterAllocator.Graph.X86'] },
    'RegAlloc.Graph.Coalesce' => { name => ['CmmToAssembler.RegisterAllocator.Graph.Coalesce'] },
    'RegAlloc.Graph.Main' => { name => ['CmmToAssembler.RegisterAllocator.Graph'] },
    'RegAlloc.Graph.Spill' => { name => ['CmmToAssembler.RegisterAllocator.Graph.Spill'] },
    'RegAlloc.Graph.SpillClean' => { name => ['CmmToAssembler.RegisterAllocator.Graph.Spill.Clean'] },
    'RegAlloc.Graph.SpillCost' => { name => ['CmmToAssembler.RegisterAllocator.Graph.Spill.Cost'] },
    'RegAlloc.Graph.Stats' => { name => ['CmmToAssembler.RegisterAllocator.Graph.Statistics'] },
    'RegAlloc.Graph.TrivColorable' => { name => ['CmmToAssembler.RegisterAllocator.Graph.TriviallyColourable'] },
    'RegAlloc.Linear.Base' => { name => ['CmmToAssembler.RegisterAllocator.Linear.Base'] },
    'RegAlloc.Linear.FreeRegs' => { name => ['CmmToAssembler.RegisterAllocator.Linear.FreeRegisters'] },
    'RegAlloc.Linear.JoinToTargets' => { name => ['CmmToAssembler.RegisterAllocator.Linear.JoinToTargets'] },
    'RegAlloc.Linear.Main' => { name => ['CmmToAssembler.RegisterAllocator.Linear'] },
    'RegAlloc.Linear.PPC.FreeRegs' => { name => ['CmmToAssembler.RegisterAllocator.Linear.PPC'] },
    'RegAlloc.Linear.SPARC.FreeRegs' => { name => ['CmmToAssembler.RegisterAllocator.Linear.SPARC'] },
    'RegAlloc.Linear.StackMap' => { name => ['CmmToAssembler.RegisterAllocator.Linear.StackMap'] },
    'RegAlloc.Linear.State' => { name => ['CmmToAssembler.RegisterAllocator.Linear.State'] },
    'RegAlloc.Linear.Stats' => { name => ['CmmToAssembler.RegisterAllocator.Linear.Statistics'] },
    'RegAlloc.Linear.X86.FreeRegs' => { name => ['CmmToAssembler.Register.Allocator.Linear.X86'] },
    'RegAlloc.Linear.X86_64.FreeRegs' => { name => ['CmmToAssembler.RegisterAllocator.Linear.X86_64'] },
    'RegAlloc.Liveness' => { name => ['CmmToAssembler.RegisterAllocator.Liveness'] },
    'RegClass' => { name => ['Platform.Register.Class'] },
    'RepType' => { name => ['Types.Representation'] },
    'RnBinds' => { name => ['Rename.Bindings'] },
    'RnEnv' => {
	name => ['Rename.Environment'],
	doc => 'functions which convert `GHC.Reader.Name.RdrName`s into `GHC.Name.Name`s.',
    },
    'RnExpr' => { name => ['Rename.Expression'] },
    'RnFixity' => { name => ['Rename.Fixity'] },
    'RnHsDoc' => { name => ['Rename.DocumentationString'] },
    'RnModIface' => { name => ['Interface.Rename'] },
    'RnNames' => { name => ['Rename.Names'] },
    'RnPat' => { name => ['Rename.Pattern'] },
    'RnSource' => { name => ['Rename.Module'] },
    'RnSplice' => { name => ['Rename.Splice'] },
    'RnTypes' => { name => ['Rename.Haskell.Type'] },
    'RnUnbound' => { name => ['Rename.Unbound'] },
    'RnUtils' => { name => ['Rename.Utilities'] },
    'RtClosureInspect' => { name => ['Runtime.Heap.Inspection'] },
    'Rules' => { name => ['Core.Rules'] },
    'SAT' => { name => ['Core.Optimize.StaticArgumentTransformation'] },
    # 'Settings' => { name => ['Settings'] },
    'SMRep' => { name => ['Runtime.Heap.Layout'] },
    'SPARC.AddrMode' => { name => ['CmmToAssembler.SPARC.AddressMode'] },
    'SPARC.Base' => { name => ['CmmToAssembler.SPARC.Base'] },
    'SPARC.CodeGen' => { name => ['CmmToAssembler.SPARC.CodeGen'] },
    'SPARC.CodeGen.Amode' => { name => ['CmmToAssembler.SPARC.CodeGen.AddressMode'] },
    'SPARC.CodeGen.Base' => { name => ['CmmToAssembler.SPARC.CodeGen.Base'] },
    'SPARC.CodeGen.CondCode' => { name => ['CmmToAssembler.SPARC.CodeGen.ConditionCode'] },
    'SPARC.CodeGen.Expand' => { name => ['CmmToAssembler.SPARC.CodeGen.Expand'] },
    'SPARC.CodeGen.Gen32' => { name => ['CmmToAssembler.SPARC.CodeGen.Gen32'] },
    'SPARC.CodeGen.Gen64' => { name => ['CmmToAssembler.SPARC.CodeGen.Gen64'] },
    'SPARC.CodeGen.Sanity' => { name => ['CmmToAssembler.SPARC.CodeGen.Sanity'] },
    'SPARC.Cond' => { name => ['CmmToAssembler.SPARC.Condition'] },
    'SPARC.Imm' => { name => ['CmmToAssembler.SPARC.ImmediateValue'] },
    'SPARC.Instr' => { name => ['CmmToAssembler.SPARC.Instruction'] },
    'SPARC.Ppr' => { name => ['CmmToAssembler.SPARC.PrettyPrint'] },
    'SPARC.Regs' => { name => ['CmmToAssembler.SPARC.Registers'] },
    'SPARC.ShortcutJump' => { name => ['CmmToAssembler.SPARC.ShortcutJump'] },
    'SPARC.Stack' => { name => ['CmmToAssembler.SPARC.Stack'] },
    'SetLevels' => { name => ['Core.Optimize.SetLevels'] },
    'SimplCore' => { name => ['Core.Optimize.Simplify.Driver'] },
    'SimplEnv' => { name => ['Core.Optimize.Simplify.Environment'] },
    'SimplMonad' => { name => ['Core.Optimize.Simplify.Monad'] },
    'SimplStg' => { name => ['SharedTermGraph.Pipeline'] },
    'SimplUtils' => { name => ['Core.Optimize.Simplify.Utilities'] },
    'Simplify' => { name => ['Core.Optimize.Simplify'] },
    'SpecConstr' => { name => ['Core.Optimize.Specialise.Constructors'] },
    'Specialise' => { name => ['Core.Optimize.Specialise'] },
    'SrcLoc' => { name => ['Types.SourceLocation'] },
    'State' => { name => ['Utilities.Monad.State'] },
    'StaticPtrTable' => { name => ['Interface.Tidy.StaticPointerTable'] },
    'StgCmm' => { name => ['SharedTermGraphToCmm'] },
    'StgCmmArgRep' => { name => ['SharedTermGraphToCmm.ArgumentRepresentations'] },
    'StgCmmBind' => { name => ['SharedTermGraphToCmm.Bindings'] },
    'StgCmmClosure' => { name => ['SharedTermGraphToCmm.Closure'] },
    'StgCmmCon' => { name => ['SharedTermGraphToCmm.Constructors'] },
    'StgCmmEnv' => { name => ['SharedTermGraphToCmm.Environment'] },
    'StgCmmExpr' => { name => ['SharedTermGraphToCmm.Expression'] },
    'StgCmmExtCode' => { name => ['SharedTermGraphToCmm.ExtendedCode'] },
    'StgCmmForeign' => { name => ['SharedTermGraphToCmm.ForeignCalls'] },
    'StgCmmHeap' => { name => ['SharedTermGraphToCmm.Heap'] },
    'StgCmmHpc' => { name => ['SharedTermGraphToCmm.HaskellProgramCoverage'] },
    'StgCmmLayout' => { name => ['SharedTermGraphToCmm.Layout'] },
    'StgCmmMonad' => { name => ['SharedTermGraphToCmm.Monad'] },
    'StgCmmPrim' => { name => ['SharedTermGraphToCmm.Primitives'] },
    'StgCmmProf' => { name => ['SharedTermGraphToCmm.Profiling'] },
    'StgCmmTicky' => { name => ['SharedTermGraphToCmm.Ticky'] },
    'StgCmmUtils' => { name => ['SharedTermGraphToCmm.Utilities'] },
    'StgCse' => { name => ['SharedTermGraph.CommonSubexpressionElimination'] },
    # 'StgFVs' => { name => ['SharedTermGraph.FreeVariables'] },
    # 'StgLiftLams.Analysis' => { name => ['SharedTermGraph.Lift.Analysis'] },
    # 'StgLiftLams.LiftM' => { name => ['SharedTermGraph.Lift.Monad'] },
    # 'StgLiftLams.Transformation' => { name => ['SharedTermGraph.Lift'] },
    'StgLint' => { name => ['SharedTermGraph.Lint'] },
    'StgStats' => { name => ['SharedTermGraph.Statistics'] },
    # 'StgSubst' => { name => ['SharedTermGraph.Substitutions'] },
    'StgSyn' => { name => ['SharedTermGraph.Syntax'] },
    'Stream' => { name => ['Data.Stream'] },
    'StringBuffer' => { name => ['Data.StringBuffer'] },
    'SysTools' => { name => ['SystemTools'] },
    'SysTools.BaseDir' => { name => ['SystemTools.BaseDirectory'] },
    'SysTools.ExtraObj' => { name => ['SystemTools.ExtraObject'] },
    'SysTools.Info' => { name => ['SystemTools.Info'] },
    'SysTools.Process' => { name => ['SystemTools.Process'] },
    # 'SysTools.Settings' => { name => ['Settings.IO'] },
    'SysTools.Tasks' => { name => ['SystemTools.Tasks'] },
    'SysTools.Terminal' => { name => ['SystemTools.Terminal'] },
    'THNames' => { name => ['Builtin.Names.TemplateHaskell'] },
    'TargetReg' => { name => ['CmmToAssembler.RegisterAllocator.Target'] },
    'TcAnnotations' => { name => ['Typecheck.Generalized.Annotations'] },
    'TcArrows' => { name => ['Typecheck.Generalized.Arrows'] },
    'TcBackpack' => { name => ['Typecheck.Utilities.Backpack'] },
    'TcBinds' => { name => ['Typecheck.Generalized.Bindings'] },
    'TcCanonical' => { name => ['Typecheck.Solver.Canonicalizer'] },
    'TcClassDcl' => { name => ['Typecheck.TypeClass.Instance'] },
    'TcDefaults' => { name => ['Typecheck.Generalized.Default'] },
    'TcDeriv' => {
	name => ['Typecheck.Deriving'],
	doc => 'Handles @deriving@ clauses on @data@ declarations.'
    },
    'TcDerivInfer' => {
	name => ['Typecheck.Deriving.Inference'],
	doc => 'Functions for inferring (and simplifying) the context for derived instances.'
    },
    'TcDerivUtils' => {
	name => ['Typecheck.Deriving.Utilities'],
	doc => 'Error-checking and other utilities for @deriving@ clauses or declarations.'
    },
    'TcEnv' => { name => ['Typecheck.Utilities.Environment'] },
    'TcErrors' => { name => ['Typecheck.Errors'] },
    'TcEvTerm' => { name => ['Typecheck.Types.Evidence.Term'] },
    'TcEvidence' => { name => ['Typecheck.Types.Evidence'] },
    'TcExpr' => { name => ['Typecheck.Generalized.Expression'] },
    'TcFlatten' => { name => ['Typecheck.Solver.Flatten'] },
    'TcForeign' => { name => ['Typecheck.Generalized.ForeignDeclaration'] },
    'TcGenDeriv' => {
	name => ['Typecheck.Deriving.Generate'],
	doc => 'Generating derived instance declarations
--
-- This module is nominally /subordinate/ to "GHC.Typecheck.Deriving", which is the /official/ interface to deriving-related things.
--
-- This is where we do all the grimy bindings\' generation.'
    },
    'TcGenFunctor' => {
	name => ['Typecheck.Deriving.Functor'],
	doc => 'The deriving code for the `Functor`, `Foldable`, and `Traversable` classes (equivalent to the code in "GHC.Typecheck.Generating.Derived", for other classes).'
    },
    'TcGenGenerics' => {
	name => ['Typecheck.Deriving.Generics'],
	doc => 'The deriving code for the `GHC.Generics.Generic` class (equivalent to the code in "GHC.Typecheck.Deriving.Generate", for other classes)'
    },
    'TcHoleErrors' => { name => ['Typecheck.Errors.Hole'] },
    # 'TcHoleFitTypes' => { name => ['Typecheck.Errors.Hole.FitTypes'] },
    'TcHsSyn' => {
	name => ['Typecheck.Utilities.Zonk'],
	doc => 'Specialisations of the "GHC.Haskell.Syntax" syntax for the typechecker.
--
-- This module is an extension of "GHC.Haskell.Syntax" syntax, for use in the type checker.',
    },
    'TcHsType' => { name => ['Typecheck.Generalized.HaskellType'] },
    'TcIface' => { name => ['InterfaceToCore'] },
    'TcInstDcls' => { name => ['Typecheck.InstanceDeclarations'] },
    'TcInteract' => { name => ['Typecheck.Solver.Interaction'] },
    'TcMType' => { name => ['Typecheck.Utilities.Type.Monad'] },
    'TcMatches' => { name => ['Typecheck.Generalized.Match'] },
    # 'TcOrigin' => { name => ['Typecheck.Types.Origin'] },
    'TcPat' => { name => ['Typecheck.Generalized.Pattern'] },
    'TcPatSyn' => { name => ['Typecheck.TypeClass.PatternSynonym'] },
    'TcPluginM' => { name => ['Typecheck.Plugin'] },
    'TcRnDriver' => {
	name => ['Typecheck.Module'],
	doc => '__Typechecking a whole module__
--
-- https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/TypeChecker'
    },
    'TcRnExports' => { name => ['Typecheck.Generalized.Export'] },
    'TcRnMonad' => {
	name => ['Typecheck.Utilities.Monad'],
	doc => 'Functions for working with the typechecker environment (setters, getters...).'
    },
    'TcRnTypes' => {
	name => ['Typecheck.Types'],
	doc => 'Various types used during typechecking, please see "GHC.Typecheck.Renaming.Monad" as well for operations on these types. You probably want to import it, instead of this module.
--
-- All the monads exported here are built on top of the same `GHC.Data.IOEnvironment.IOEnv` monad. The monad functions like a `Control.Monad.Trans.Reader.Reader` monad in the way it passes the environment around. This is done to allow the environment to be manipulated in a stack like fashion when entering expressions... etc.
--
-- For state that is global and should be returned at the end (e.g not part of the stack mechanism), you should use a `Old.TcRef` (= `Data.IORef.IORef`) to store them.'
    },
    'TcRules' => { name => ['Typecheck.Generalized.Rule'] },
    'TcSMonad' => {
	name => ['Typecheck.Solver.Monad'],
	doc => 'Type definitions for the constraint solver.',
	hidden => ['isFilledMetaTyVar'],
	rename => [
	    { old => 'isFilledMetaTyVar_maybe', new => 'isFilledMetaTyVar' }
	    ]
    },
    'TcSigs' => { name => ['Typecheck.Generalized.Signature'] },
    'TcSimplify' => { name => ['Typecheck.Solver'] },
    'TcSplice' => { name => ['Typecheck.Gen.Splice'] },
    'TcTyClsDecls' => { name => ['Typecheck.TypeClass'] },
    'TcTyDecls' => { name => ['Typecheck.TypeClass.Utilities'] },
    'TcType' => { name => ['Typecheck.Utilities.Type'] },
    'TcTypeNats' => { name => ['Builtin.Types.Literals'] },
    'TcTypeable' => { name => ['Typecheck.Instance.Typeable'] },
    'TcUnify' => { name => ['Typecheck.Utilities.Unify'] },
    'TcValidity' => { name => ['Typecheck.Validity'] },
    'TidyPgm' => { name => ['Interface.Tidy'] },
    'TmOracle' => { name => ['HaskellToCore.PatternMatchCheck.Oracle'] },
    'ToIface' => { name => ['CoreToInterface'] },
    # 'ToolSettings' => { name => ['Settings.Tool'] },
    'TrieMap' => { name => ['Data.Map.Trie'] },
    # 'TyCoFVs' => { name => ['Core.TypeCoercion.FreeVariables'] },
    # 'TyCoPpr' => { name => ['Core.TypeCoercion.PrettyPrint'] },
    'TyCoRep' => { name => ['Core.TypeCoercion.Representation'] },
    # 'TyCoSubst' => { name => ['Core.TypeCoercion.Substitutions'] },
    # 'TyCoTidy' => { name => ['Core.TypeCoercion.Tidy'] },
    'TyCon' => { name => ['Core.TypeConstructor'] },
    'Type' => {
	name => ['Core.Type'],
	doc => 'Main functions for manipulating types and type-related things.',
	hidden => [
	    'getClassPredTys',
	    'getEqPredTys',
	    'getRuntimeRep',
	    'getTyVar',
	    'isCoercionTy',
	    'isIPPred',
	    'splitAppTy',
	    'splitFunTy',
	    'splitPiTy',
	    'splitTyConApp',
	    'tyConAppArgs',
	    'tyConAppTyCon'
	    ],
	rename => [
	    { old => 'binderRelevantType_maybe', new => 'binderRelevantType',
	      doc => 'Extract a relevant type, if there is one.'
	    },
	    { old => 'getCastedTyVar_maybe', new => 'getCastedTyVar'} ,
	    { old => 'getClassPredTys_maybe', new => 'getClassPredTys' },
	    { old => 'getEqPredTys_maybe', new => 'getEqPredTys' },
	    { old => 'getRuntimeRepFromKind_maybe', new => 'getRuntimeRepFromKind' },
	    { old => 'getRuntimeRep_maybe', new => 'getRuntimeRep' },
	    { old => 'getTyVar_maybe', new => 'getTyVar' },
	    { old => 'isCoercionTy_maybe', new => 'isCoercionTy' },
	    { old => 'isIPPred_maybe', new => 'isIPPred' },
	    { old => 'isLiftedType_maybe', new => 'isLiftedType' },
	    { old => 'repGetTyVar_maybe', new => 'repGetTyVar' },
	    { old => 'repSplitAppTy_maybe', new => 'repSplitAppTy' },
	    { old => 'repSplitTyConApp_maybe', new => 'repSplitTyConApp' },
	    { old => 'splitAppTy_maybe', new => 'splitAppTy' },
	    { old => 'splitCastTy_maybe', new => 'splitCastTy' },
	    { old => 'splitCoercionType_maybe', new => 'splitCoercionType' },
	    { old => 'splitForAllTy_maybe', new => 'splitForAllTy' },
	    { old => 'splitFunTy_maybe', new => 'splitFunTy' },
	    { old => 'splitListTyConApp_maybe', new => 'splitListTyConApp' },
	    { old => 'splitPiTy_maybe', new => 'splitPiTy' },
	    { old => 'splitTyConApp_maybe', new => 'splitTyConApp' },
	    { old => 'tcRepSplitAppTy_maybe', new => 'tcRepSplitAppTy' },
	    { old => 'tcRepSplitTyConApp_maybe', new => 'tcRepSplitTyConApp' },
	    { old => 'tcSplitTyConApp_maybe', new => 'tcSplitTyConApp' },
	    { old => 'tyBinderVar_maybe', new => 'tyBinderVar' },
	    { old => 'tyConAppArgs_maybe', new => 'tyConAppArgs' },
	    { old => 'tyConAppTyConPicky_maybe', new => 'tyConAppTyConPicky' },
	    { old => 'tyConAppTyCon_maybe', new => 'tyConAppTyCon' },
	    { old => 'userTypeError_maybe', new => 'userTypeError' },
	    ]
    },
    'TysPrim' => { name => ['Builtin.Types.Primitive'] },
    'TysWiredIn' => { name => ['Builtin.Types'] },
    # 'UnitInfo' => { name => ['Unit.Info'] },
    'UnVarGraph' => { name => ['Data.Graph.UndirectedVariable'] },
    'UnariseStg' => { name => ['SharedTermGraph.Unarise'] },
    'Unify' => { name => ['Core.Unify'] },
    'UniqDFM' => { name => ['Types.Unique.Map.Finite.Deterministic'] },
    'UniqDSet' => { name => ['Types.Unique.Set.Deterministic'] },
    'UniqFM' => { name => ['Types.Unique.Map.Finite'] },
    'UniqMap' => { name => ['Types.Unique.Map'] },
    'UniqSet' => {
	name => ['Types.Unique.Set'],
	doc => 'Specialised sets, for things with `GHC.Unique.Unique`s.
--
-- Based on "GHC.Unique.Map.Finite" (as you would expect).
--
-- Basically, the things need to be in class `GHC.Unique.Uniquable`.
',
    },
    'UniqSupply' => { name => ['Types.Unique.Supply'] },
    'Unique' => {
	name => ['Types.Unique'],
	doc => '`GHC.Unique.Unique`s are used to distinguish entities in the compiler (`GHC.Types.Id.Id`s, `GHC.Core.Class.Class`es, etc.) from each other. Thus, `GHC.Types.Unique.Unique`s are the basic comparison key in the compiler.
--
-- If there is any single operation that needs to be fast, it is `GHC.Unique.Unique` comparison. Unsurprisingly, there is quite a bit of huff-and-puff directed to that end.
--
-- Some of the other hair in this code is to be able to use a splittable `GHC.Unique.Supply.UniqSupply` if requested/possible (not standard Haskell).',
    },
    # 'UpdateCafInfos' => { name => ['Interface.UpdateCafInfos'] },
    'Util' => { name => ['Utilities.Miscellaneous'] },
    'Var' => { name => ['Types.Variable'] },
    'VarEnv' => { name => ['Types.Variable.Environment'] },
    'VarSet' => { name => ['Types.Variable.Set'] },
    'WorkWrap' => { name => ['Core.Optimize.WorkerWrapper'] },
    'WwLib' => { name => ['Core.Optimize.WorkerWrapper.Library'] },
    'X86.CodeGen' => { name => ['CmmToAssembler.X86.CodeGen'] },
    'X86.Cond' => { name => ['CmmToAssembler.X86.Condition'] },
    'X86.Instr' => { name => ['CmmToAssembler.X86.Instructions'] },
    'X86.Ppr' => { name => ['CmmToAssembler.X86.PrettyPrint'] },
    'X86.RegInfo' => { name => ['CmmToAssembler.X86.Registers.Info'] },
    'X86.Regs' => { name => ['CmmToAssembler.X86.Registers'] },
);

my $tt = Template->new({
    INCLUDE_PATH => './templates',
}) || die "$Template::ERROR\n";

my $script = basename($0);

my $warning = "-- __WARNING__: This file is automatically generated by ${script}.
-- It is not managed by version control. Any changes you make to it will be lost.";

while (my ($k, $v) = each %modules)
{
    my $name_list = $v->{name};
    unshift(@$name_list, 'GHC');
    $v->{name} = join('.', @$name_list);
    $modules{$k} = $v;
};

my $cabal_vars = {
    warning => $warning,
    modules => [sort (map { $_->{name} } values %modules)]
};

$tt->process('ghc-user.cabal.template', $cabal_vars, './ghc-user.cabal')
    || die $tt->error(), "\n";

while (my ($old_module_name, $new_module) = each %modules)
{
    my $vars = {
	warning => $warning,
	old => $old_module_name,
	new => $new_module->{name},
	doc => $new_module->{doc},
	hidden => $new_module->{hidden},
	rename => $new_module->{rename}
    };

    $new_module->{name} =~ s/\./\//g;
    my $output = "./src/" . $new_module->{name} . ".hs";
 
    $tt->process('Module.hs.template', $vars, $output)
	|| die $tt->error(), "\n";
}
